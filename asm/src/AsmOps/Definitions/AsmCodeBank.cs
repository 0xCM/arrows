//-----------------------------------------------------------------------------
// Copyright   :  (c) Chris Moore, 2019
// License     :  MIT
//-----------------------------------------------------------------------------
namespace Z0.Asm
{
    using System;
    using System.Security;
    using System.Runtime.CompilerServices;
    using System.Runtime.InteropServices;

    using static zfunc;

    public static class AsmCodeBank
    {
        static AsmCodeBank()
        {
            add8iBytes.Unprotect();   
            add8uBytes.Unprotect();   
            add16iBytes.Unprotect();   
            add16uBytes.Unprotect();   
            add32iBytes.Unprotect();   
            add32uBytes.Unprotect();   
            add64iBytes.Unprotect();   
            add64uBytes.Unprotect();   
            add32fBytes.Unprotect();   
            add64fBytes.Unprotect();   

            negate8iBytes.Unprotect();   
            negate8uBytes.Unprotect();   
            negate16iBytes.Unprotect();   
            negate16uBytes.Unprotect();   
            negate32iBytes.Unprotect();   
            negate32uBytes.Unprotect();   
            negate64iBytes.Unprotect();   
            negate64uBytes.Unprotect();   
            negate32fBytes.Unprotect();   
            negate64fBytes.Unprotect();   
        }

        /// <summary>
        /// The handle for the current process
        /// </summary>
        static readonly IntPtr ProcHandle = System.Diagnostics.Process.GetCurrentProcess().Handle;

        unsafe static IntPtr Unprotect(this ReadOnlySpan<byte> src)
        {
            var pCode = (IntPtr)Z0.As.refptr(ref Z0.As.asRef(in src[0]));
            if (!OS.VirtualProtectEx(ProcHandle, pCode, (UIntPtr)src.Length, 0x40, out uint _))
                throw new Exception("VirtualProtectEx failed");     
            return pCode;

        }
        public static ReadOnlySpan<byte> add8iBytes => new byte[20]{0x0F,0x1F,0x44,0x00,0x00,0x48,0x0F,0xBE,0xC1,0x48,0x0F,0xBE,0xD2,0x03,0xC2,0x48,0x0F,0xBE,0xC0,0xC3};    

        public static ReadOnlySpan<byte> add8uBytes => new byte[17]{0x0F,0x1F,0x44,0x00,0x00,0x0F,0xB6,0xC1,0x0F,0xB6,0xD2,0x03,0xC2,0x0F,0xB6,0xC0,0xC3};
  
        public static ReadOnlySpan<byte> add16iBytes => new byte[20]{0x0F,0x1F,0x44,0x00,0x00,0x48,0x0F,0xBF,0xC1,0x48,0x0F,0xBF,0xD2,0x03,0xC2,0x48,0x0F,0xBF,0xC0,0xC3};        

        public static ReadOnlySpan<byte> add16uBytes => new byte[17]{0x0F,0x1F,0x44,0x00,0x00,0x0F,0xB7,0xC1,0x0F,0xB7,0xD2,0x03,0xC2,0x0F,0xB7,0xC0,0xC3};        

        public static ReadOnlySpan<byte> add32iBytes => new byte[9]{0x0F,0x1F,0x44,0x00,0x00,0x8D,0x04,0x11,0xC3};
  
        public static ReadOnlySpan<byte> add32uBytes => new byte[9]{0x0F,0x1F,0x44,0x00,0x00,0x8D,0x04,0x11,0xC3};

        public static ReadOnlySpan<byte> add64iBytes => new byte[10]{0x0F,0x1F,0x44,0x00,0x00,0x48,0x8D,0x04,0x11,0xC3};        
  
        public static ReadOnlySpan<byte> add64uBytes => new byte[10]{0x0F,0x1F,0x44,0x00,0x00,0x48,0x8D,0x04,0x11,0xC3};
        
        public static ReadOnlySpan<byte> add32fBytes => new byte[10]{0xC5,0xF8,0x77,0x66,0x90,0xC5,0xFA,0x58,0xC1,0xC3};
        
        public static ReadOnlySpan<byte> add64fBytes => new byte[10]{0xC5,0xF8,0x77,0x66,0x90,0xC5,0xFB,0x58,0xC1,0xC3};

        public static ReadOnlySpan<byte> negate8uBytes => new byte[16]{0x0F,0x1F,0x44,0x00,0x00,0x0F,0xB6,0xC1,0xF7,0xD0,0xFF,0xC0,0x0F,0xB6,0xC0,0xC3};

        public static ReadOnlySpan<byte> negate8iBytes => new byte[16]{0x0F,0x1F,0x44,0x00,0x00,0x48,0x0F,0xBE,0xC1,0xF7,0xD8,0x48,0x0F,0xBE,0xC0,0xC3};

        public static ReadOnlySpan<byte> negate16iBytes => new byte[16]{0x0F,0x1F,0x44,0x00,0x00,0x48,0x0F,0xBF,0xC1,0xF7,0xD8,0x48,0x0F,0xBF,0xC0,0xC3};

        public static ReadOnlySpan<byte> negate16uBytes => new byte[16]{0x0F,0x1F,0x44,0x00,0x00,0x0F,0xB7,0xC1,0xF7,0xD0,0xFF,0xC0,0x0F,0xB7,0xC0,0xC3};

        public static ReadOnlySpan<byte> negate32iBytes => new byte[10]{0x0F,0x1F,0x44,0x00,0x00,0x8B,0xC1,0xF7,0xD8,0xC3};

        public static ReadOnlySpan<byte> negate32uBytes => new byte[12]{0x0F,0x1F,0x44,0x00,0x00,0x8B,0xC1,0xF7,0xD0,0xFF,0xC0,0xC3};

        public static ReadOnlySpan<byte> negate64iBytes => new byte[12]{0x0F,0x1F,0x44,0x00,0x00,0x48,0x8B,0xC1,0x48,0xF7,0xD8,0xC3};

        public static ReadOnlySpan<byte> negate64uBytes => new byte[15]{0x0F,0x1F,0x44,0x00,0x00,0x48,0x8B,0xC1,0x48,0xF7,0xD0,0x48,0xFF,0xC0,0xC3};

        public static ReadOnlySpan<byte> negate32fBytes => new byte[18]{0xC5,0xF8,0x77,0x66,0x90,0xC5,0xF0,0x57,0xC9,0xC5,0xF2,0x5C,0xC8,0xC5,0xF8,0x28,0xC1,0xC3};

        public static ReadOnlySpan<byte> negate64fBytes => new byte[18]{0xC5,0xF8,0x77,0x66,0x90,0xC5,0xF0,0x57,0xC9,0xC5,0xF3,0x5C,0xC8,0xC5,0xF8,0x28,0xC1,0xC3};
   }

}